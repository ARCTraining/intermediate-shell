---
title: "Makefile"
teaching: 25
exercises: 20
questions:
- "How can I find things in files?"
objectives:
- "Use `grep` to select lines from text files that match simple patterns."
keypoints:
- "`grep` selects lines in files that match patterns."
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(comment="")
```

Make is a build automation tool
that can be used for all kind of workflows
and remains widely used.

The description of the relationship between files that Make manages is stored in a file called `Makefile`
and Make is smart enough to decide which of the files need to be updated and how to do it.
A simple `Makefile` consists of "rules"" with the following shape:

```
target: [prerequisites]...
	recipes...
```

- target: is usually the name of a file that is generated by a program but can also be the name of an action to carry out.
- prerequisite: is a file that is used as input to create the target.
- recipe: is an action that Make carries out. **A tab character must be put at the beginning of every recipe line!**

The smallest Makefile that we could have is

```{bash}
cat 05-01-makefile/Makefile
```

It has a target called `help`,
with no prerequisites
and one recipe, `echo "Welcome"`.
We can run it with

```{bash}
make -C 05-01-makefile
```

If we are using R Markdown to write one article,
we could have a `Makefile` like

```{bash}
cat 05-02-makefile/Makefile
```

that would process the R Markdown file and create one Microsoft Office Word document from it.

```{bash, include=FALSE}
touch 05-02-makefile/article.Rmd
```

```{bash}
make -C 05-02-makefile
```

If we call Make another time,
it would know that the prerequisite didn't change
and, because of it,
the recipes doesn't need to be used to recreated the target.

```{bash}
make -C 05-02-makefile
```

This is feature from Make can save users a lot of time
and why Make remains widely used.

In our previous example,
we only had one target.
If we also want to create a HTML file from the R Markdown file,
we can add another target.
And to ensure that the HTML file and the Microsoft Office Word file will be both created,
we cacn have a third target called `all`.

```{bash}
cat 05-03-makefile/Makefile
```

Note that the prerequisites for the target `all` are later described as targets.
This allow users to only build one target, if they want,
and avoid repetition of rules.

```{bash, include=FALSE}
touch 05-03-makefile/article.Rmd
```

```{bash}
make -C 05-03-makefile
```

Talking about repetition,
we can use variables in `Makefile`.

```{bash}
cat 05-04-makefile/Makefile
```

```{bash, include=FALSE}
touch 05-04-makefile/article.Rmd
```

```{bash}
make -C 05-04-makefile
```

In the previous example,
we defined our own variable.
Make has automatic variables that have their values computed afresh for each rule that is executed, based on the target and prerequisites of the rule.
Some of the automatic variables are

- `$@`: the file name of the target of the rule.
- `$<`: the name of the first prerequisite.
- `$?`: the names of all the prerequisites that are newer than the target, with spaces between them.
- `$^`: the names of all the prerequisites, with spaces between them. **No duplicated names!**

Make has some built-in functions for transforming text.
This functions are very handful to avoid repetition even more.

```{bash}
cat 05-05-makefile/Makefile
```

We should be careful to not end up with a `Makefile` that is unreadable.

```{bash, include=FALSE}
touch 05-05-makefile/article.Rmd
```

```{bash}
make -C 05-05-makefile
```

Some of the built-in functions are

- `$(subst from,to,text)`: performs a textual replacement on the text `text`: **all** occurrence of `from` is replaced by `to`.
- `$(findstring find,in)`: searches `in` for an occurrence of `find`. If it occurs, the value is `find`; otherwise, the value is empty.
- `$(sort list)`: sorts the words of `list` in lexical order, **removing duplicate words**.
- `$(word n,text)`: returns the nth word of text.
- `$(words text)`: returns the number of words in text.
- `$(dir names...)`: extracts the directory-part of each file name in `names`.
- `$(notdir names...)`: extracts all but the directory-part of each file name in `names`.
- `$(suffix names...)`: extracts the suffix of each file name in `names`.
- `$(basename names...)`: extracts all but the suffix of each file name in `names`.
- `$(addsuffix suffix,names…)`: the value of `suffix` is appended to the end of each individual `name` and the resulting larger `names` are concatenated with single spaces between them.
- `$(addprefix prefix,names...)`: the value of `prefix` is prepended to the front of each individual `name` and the resulting larger `names` are concatenated with single spaces between them.
- `$(join list1,list2)`: concatenates the two arguments word by word.
- `$(wildcard pattern)`: the result is a space-separated list of the names of existing files that match the pattern.
- `$(realpath names...)`: for each file name in names return the canonical absolute name.
- `$(abspath names...)`: for each file name in names return an absolute name that does not contain any `.` or `..` components, nor any repeated path separators (`/`).

Another great feature of Make is that it knows how to execute several recipes at once.
So far,
Make executed each one of our recipe at a time, waiting for it to finish before executing the next.
The ‘-j’ or ‘--jobs’ option tells make to execute many recipes simultaneously.

```{bash, include=FALSE}
touch 05-05-makefile/article.Rmd
```

```{bash, error=TRUE}
make -j 2 -C 05-05-makefile
```

Depending of the machine you are using,
the `-j` option can reduce the time you wait for your task be completed.
Unfortunately, as show in the previous example, sometimes,
the program that you are using on your recipes aren't design to run in parallel
and you will end up with all kind of erros.

{% include links.md %}